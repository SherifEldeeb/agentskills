#!/usr/bin/env python3
"""
Vulnerability Management Utility Functions

Utilities for vulnerability scanning, tracking, and reporting.

Usage:
    from vuln_utils import VulnerabilityScanner, RemediationTracker, VulnMetrics
"""

import csv
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from collections import defaultdict

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Process and manage vulnerability scan results."""

    SEVERITIES = ['Critical', 'High', 'Medium', 'Low', 'Info']

    def __init__(self):
        self.findings = []

    def add_finding(self, cve_id: str, severity: str, affected_host: str,
                    description: str = '', cvss_score: float = None,
                    solution: str = '', plugin_id: str = ''):
        """Add a vulnerability finding."""
        if severity not in self.SEVERITIES:
            raise ValueError(f"Invalid severity: {severity}")
        if cvss_score is not None and not (0 <= cvss_score <= 10):
            raise ValueError(f"CVSS score must be between 0 and 10")

        self.findings.append({
            'cve_id': cve_id,
            'severity': severity,
            'affected_host': affected_host,
            'description': description,
            'cvss_score': cvss_score,
            'solution': solution,
            'plugin_id': plugin_id,
            'discovered_at': datetime.now().isoformat()
        })

    def import_csv(self, filepath: str):
        """Import findings from generic CSV."""
        with open(filepath, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                self.add_finding(
                    cve_id=row.get('cve_id', row.get('CVE', '')),
                    severity=row.get('severity', row.get('Severity', 'Medium')),
                    affected_host=row.get('host', row.get('Host', '')),
                    description=row.get('description', row.get('Description', '')),
                    cvss_score=float(row['cvss']) if row.get('cvss') else None,
                    solution=row.get('solution', row.get('Solution', ''))
                )

    def import_nessus_csv(self, filepath: str):
        """Import findings from Nessus CSV export."""
        with open(filepath, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                cvss = row.get('CVSS v3.0 Base Score') or row.get('CVSS v2.0 Base Score')
                self.add_finding(
                    cve_id=row.get('CVE', ''),
                    severity=row.get('Risk', 'Medium'),
                    affected_host=row.get('Host', ''),
                    description=row.get('Description', ''),
                    cvss_score=float(cvss) if cvss else None,
                    solution=row.get('Solution', ''),
                    plugin_id=row.get('Plugin ID', '')
                )

    def get_summary(self) -> Dict[str, int]:
        """Get finding counts by severity."""
        counts = defaultdict(int)
        for finding in self.findings:
            counts[finding['severity']] += 1
        return dict(counts)

    def get_by_severity(self, severity: str) -> List[dict]:
        """Get findings filtered by severity."""
        return [f for f in self.findings if f['severity'] == severity]

    def get_unique_cves(self) -> List[str]:
        """Get list of unique CVE IDs."""
        return list(set(f['cve_id'] for f in self.findings if f['cve_id']))

    def generate_report(self) -> str:
        """Generate vulnerability report."""
        summary = self.get_summary()

        report = f"""# Vulnerability Scan Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}
**Total Findings:** {len(self.findings)}

---

## Summary

| Severity | Count |
|----------|-------|
| Critical | {summary.get('Critical', 0)} |
| High | {summary.get('High', 0)} |
| Medium | {summary.get('Medium', 0)} |
| Low | {summary.get('Low', 0)} |

## Findings by Severity

"""
        for severity in self.SEVERITIES:
            findings = self.get_by_severity(severity)
            if findings:
                report += f"### {severity}\n\n"
                report += "| CVE | Host | Description | CVSS |\n"
                report += "|-----|------|-------------|------|\n"
                for f in findings[:20]:  # Limit to top 20 per severity
                    cvss = f['cvss_score'] if f['cvss_score'] else 'N/A'
                    desc = f['description'][:50] + '...' if len(f['description']) > 50 else f['description']
                    report += f"| {f['cve_id']} | {f['affected_host']} | {desc} | {cvss} |\n"
                report += "\n"

        return report

    def generate_executive_summary(self) -> str:
        """Generate executive summary."""
        summary = self.get_summary()
        critical = summary.get('Critical', 0)
        high = summary.get('High', 0)

        return f"""# Executive Vulnerability Summary

**Date:** {datetime.now().strftime('%Y-%m-%d')}

## Risk Overview

- **Critical Vulnerabilities:** {critical}
- **High Vulnerabilities:** {high}
- **Total Findings:** {len(self.findings)}
- **Unique CVEs:** {len(self.get_unique_cves())}

## Immediate Action Required

{critical} critical vulnerabilities require immediate attention.
"""


class RiskPrioritizer:
    """Prioritize vulnerabilities by risk."""

    def __init__(self):
        self.vulnerabilities = []

    def add_vulnerability(self, cve_id: str, cvss_score: float,
                          affected_host: str, asset_criticality: str = 'medium',
                          exploit_available: bool = False,
                          internet_facing: bool = False):
        """Add vulnerability for prioritization."""
        self.vulnerabilities.append({
            'cve_id': cve_id,
            'cvss_score': cvss_score,
            'affected_host': affected_host,
            'asset_criticality': asset_criticality,
            'exploit_available': exploit_available,
            'internet_facing': internet_facing,
            'risk_score': None
        })

    def calculate_risk_scores(self):
        """Calculate risk scores for all vulnerabilities."""
        criticality_weights = {'critical': 1.5, 'high': 1.2, 'medium': 1.0, 'low': 0.8}

        for vuln in self.vulnerabilities:
            base_score = vuln['cvss_score']

            # Apply modifiers
            criticality_mod = criticality_weights.get(vuln['asset_criticality'], 1.0)
            exploit_mod = 1.3 if vuln['exploit_available'] else 1.0
            internet_mod = 1.2 if vuln['internet_facing'] else 1.0

            risk_score = base_score * criticality_mod * exploit_mod * internet_mod
            vuln['risk_score'] = min(risk_score, 10.0)  # Cap at 10

    def get_prioritized_list(self) -> List[dict]:
        """Get vulnerabilities sorted by risk score."""
        return sorted(self.vulnerabilities, key=lambda x: x['risk_score'] or 0, reverse=True)

    def get_top_n(self, n: int) -> List[dict]:
        """Get top N vulnerabilities by risk."""
        return self.get_prioritized_list()[:n]

    def generate_risk_report(self) -> str:
        """Generate risk prioritization report."""
        prioritized = self.get_prioritized_list()

        report = f"""# Risk Prioritization Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}
**Vulnerabilities Analyzed:** {len(self.vulnerabilities)}

---

## Top Priority Vulnerabilities

| Rank | CVE | Host | CVSS | Risk Score | Factors |
|------|-----|------|------|------------|---------|
"""
        for i, vuln in enumerate(prioritized[:20], 1):
            factors = []
            if vuln['exploit_available']:
                factors.append('Exploit')
            if vuln['internet_facing']:
                factors.append('Internet')
            if vuln['asset_criticality'] in ['critical', 'high']:
                factors.append('Critical Asset')
            factors_str = ', '.join(factors) if factors else 'None'

            report += f"| {i} | {vuln['cve_id']} | {vuln['affected_host']} | {vuln['cvss_score']} | {vuln['risk_score']:.1f} | {factors_str} |\n"

        return report


class RemediationTracker:
    """Track vulnerability remediation progress."""

    DEFAULT_SLAS = {
        'Critical': 7,
        'High': 30,
        'Medium': 90,
        'Low': 180
    }

    def __init__(self):
        self.vulnerabilities = {}

    def add_vulnerability(self, cve_id: str, severity: str,
                          affected_host: str, sla_days: int = None):
        """Add vulnerability for tracking."""
        key = f"{cve_id}:{affected_host}"
        sla = sla_days or self.DEFAULT_SLAS.get(severity, 90)

        self.vulnerabilities[key] = {
            'cve_id': cve_id,
            'severity': severity,
            'affected_host': affected_host,
            'status': 'open',
            'assigned_to': None,
            'due_date': None,
            'sla_days': sla,
            'created_at': datetime.now(),
            'remediated_at': None,
            'remediation_method': None,
            'notes': []
        }

    def assign(self, cve_id: str, team: str, due_date: str = None):
        """Assign vulnerability to team."""
        for key, vuln in self.vulnerabilities.items():
            if vuln['cve_id'] == cve_id:
                vuln['assigned_to'] = team
                if due_date:
                    vuln['due_date'] = due_date
                else:
                    vuln['due_date'] = (datetime.now() + timedelta(days=vuln['sla_days'])).strftime('%Y-%m-%d')
                vuln['status'] = 'assigned'

    def update_status(self, cve_id: str, status: str, notes: str = ''):
        """Update vulnerability status."""
        for key, vuln in self.vulnerabilities.items():
            if vuln['cve_id'] == cve_id:
                vuln['status'] = status
                if notes:
                    vuln['notes'].append({
                        'timestamp': datetime.now().isoformat(),
                        'note': notes
                    })

    def mark_remediated(self, cve_id: str, method: str):
        """Mark vulnerability as remediated."""
        for key, vuln in self.vulnerabilities.items():
            if vuln['cve_id'] == cve_id:
                vuln['status'] = 'remediated'
                vuln['remediated_at'] = datetime.now()
                vuln['remediation_method'] = method

    def get_overdue(self) -> List[dict]:
        """Get overdue vulnerabilities."""
        today = datetime.now().strftime('%Y-%m-%d')
        return [v for v in self.vulnerabilities.values()
                if v['status'] not in ['remediated', 'exception']
                and v['due_date'] and v['due_date'] < today]

    def get_at_risk(self, days: int = 7) -> List[dict]:
        """Get vulnerabilities at risk of missing SLA."""
        cutoff = (datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d')
        today = datetime.now().strftime('%Y-%m-%d')
        return [v for v in self.vulnerabilities.values()
                if v['status'] not in ['remediated', 'exception']
                and v['due_date'] and today <= v['due_date'] <= cutoff]

    def generate_status_report(self) -> str:
        """Generate remediation status report."""
        status_counts = defaultdict(int)
        for vuln in self.vulnerabilities.values():
            status_counts[vuln['status']] += 1

        overdue = self.get_overdue()
        at_risk = self.get_at_risk(7)

        report = f"""# Remediation Status Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}

---

## Summary

| Status | Count |
|--------|-------|
| Open | {status_counts['open']} |
| Assigned | {status_counts['assigned']} |
| In Progress | {status_counts['in_progress']} |
| Remediated | {status_counts['remediated']} |

## SLA Status

- **Overdue:** {len(overdue)}
- **At Risk (7 days):** {len(at_risk)}

## Overdue Vulnerabilities

| CVE | Host | Severity | Due Date | Assigned To |
|-----|------|----------|----------|-------------|
"""
        for vuln in overdue[:10]:
            report += f"| {vuln['cve_id']} | {vuln['affected_host']} | {vuln['severity']} | {vuln['due_date']} | {vuln['assigned_to']} |\n"

        return report


class ExceptionManager:
    """Manage vulnerability exceptions."""

    def __init__(self):
        self.exceptions = {}

    def create_exception(self, cve_id: str, affected_host: str, reason: str,
                         compensating_controls: str, requested_by: str,
                         expiration_date: str):
        """Create exception request."""
        key = f"{cve_id}:{affected_host}"
        self.exceptions[key] = {
            'cve_id': cve_id,
            'affected_host': affected_host,
            'reason': reason,
            'compensating_controls': compensating_controls,
            'requested_by': requested_by,
            'requested_at': datetime.now().isoformat(),
            'expiration_date': expiration_date,
            'status': 'pending',
            'approved_by': None,
            'approved_at': None,
            'approval_notes': None
        }

    def approve_exception(self, cve_id: str, approved_by: str, notes: str = ''):
        """Approve exception request."""
        for key, exc in self.exceptions.items():
            if exc['cve_id'] == cve_id and exc['status'] == 'pending':
                exc['status'] = 'approved'
                exc['approved_by'] = approved_by
                exc['approved_at'] = datetime.now().isoformat()
                exc['approval_notes'] = notes

    def get_expired(self) -> List[dict]:
        """Get expired exceptions."""
        today = datetime.now().strftime('%Y-%m-%d')
        return [e for e in self.exceptions.values()
                if e['status'] == 'approved' and e['expiration_date'] < today]

    def generate_report(self) -> str:
        """Generate exception report."""
        report = f"""# Vulnerability Exception Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}

---

| CVE | Host | Status | Expires | Reason |
|-----|------|--------|---------|--------|
"""
        for exc in self.exceptions.values():
            reason = exc['reason'][:30] + '...' if len(exc['reason']) > 30 else exc['reason']
            report += f"| {exc['cve_id']} | {exc['affected_host']} | {exc['status']} | {exc['expiration_date']} | {reason} |\n"

        return report


class VulnMetrics:
    """Track vulnerability management metrics."""

    def __init__(self):
        self.scan_history = []
        self.remediation_records = []

    def add_scan_result(self, data: dict):
        """Add scan result for trending."""
        self.scan_history.append(data)

    def add_remediation_record(self, data: dict):
        """Add remediation record for MTTR calculation."""
        self.remediation_records.append(data)

    def calculate_mttr(self, severity: str = None) -> float:
        """Calculate Mean Time to Remediate in days."""
        records = self.remediation_records
        if severity:
            records = [r for r in records if r.get('severity') == severity]

        if not records:
            return 0

        times = []
        for r in records:
            if r.get('detected_at') and r.get('remediated_at'):
                detected = datetime.fromisoformat(r['detected_at'])
                remediated = datetime.fromisoformat(r['remediated_at'])
                times.append((remediated - detected).days)

        return sum(times) / len(times) if times else 0

    def calculate_sla_compliance(self) -> float:
        """Calculate SLA compliance percentage."""
        if not self.remediation_records:
            return 100.0

        compliant = sum(1 for r in self.remediation_records
                       if r.get('sla_met', True))
        return (compliant / len(self.remediation_records)) * 100

    def calculate_remediation_rate(self) -> float:
        """Calculate remediation rate percentage."""
        if not self.remediation_records:
            return 0

        remediated = sum(1 for r in self.remediation_records
                        if r.get('remediated_at'))
        return (remediated / len(self.remediation_records)) * 100

    def get_vulnerability_trend(self, days: int = 90) -> List[dict]:
        """Get vulnerability trending data."""
        cutoff = datetime.now() - timedelta(days=days)
        return [s for s in self.scan_history
                if datetime.fromisoformat(s['date']) > cutoff]

    def generate_report(self) -> str:
        """Generate metrics report."""
        return f"""# Vulnerability Management Metrics

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}

---

## Key Performance Indicators

| Metric | Value |
|--------|-------|
| MTTR (Critical) | {self.calculate_mttr('Critical'):.1f} days |
| MTTR (High) | {self.calculate_mttr('High'):.1f} days |
| MTTR (All) | {self.calculate_mttr():.1f} days |
| SLA Compliance | {self.calculate_sla_compliance():.1f}% |
| Remediation Rate | {self.calculate_remediation_rate():.1f}% |

## Data Points

- Scan Records: {len(self.scan_history)}
- Remediation Records: {len(self.remediation_records)}
"""


class AssetVulnerabilityView:
    """View vulnerabilities by asset."""

    def __init__(self):
        self.assets = defaultdict(lambda: {'vulnerabilities': [], 'criticality': 'medium'})

    def add_asset_vulnerability(self, asset: str, cve_id: str, severity: str):
        """Add vulnerability to asset."""
        self.assets[asset]['vulnerabilities'].append({
            'cve_id': cve_id,
            'severity': severity
        })

    def set_asset_criticality(self, asset: str, criticality: str):
        """Set asset criticality level."""
        self.assets[asset]['criticality'] = criticality

    def get_asset_summary(self, asset: str) -> dict:
        """Get vulnerability summary for asset."""
        if asset not in self.assets:
            return {}

        vulns = self.assets[asset]['vulnerabilities']
        counts = defaultdict(int)
        for v in vulns:
            counts[v['severity']] += 1

        return {
            'asset': asset,
            'criticality': self.assets[asset]['criticality'],
            'total': len(vulns),
            'by_severity': dict(counts)
        }

    def get_highest_risk_assets(self, limit: int = 10) -> List[dict]:
        """Get assets with highest risk."""
        risk_scores = []
        weights = {'Critical': 10, 'High': 5, 'Medium': 2, 'Low': 1}

        for asset, data in self.assets.items():
            score = sum(weights.get(v['severity'], 0) for v in data['vulnerabilities'])
            risk_scores.append({
                'asset': asset,
                'criticality': data['criticality'],
                'risk_score': score,
                'vuln_count': len(data['vulnerabilities'])
            })

        return sorted(risk_scores, key=lambda x: x['risk_score'], reverse=True)[:limit]

    def generate_asset_report(self, asset: str) -> str:
        """Generate report for specific asset."""
        if asset not in self.assets:
            return f"Asset {asset} not found"

        summary = self.get_asset_summary(asset)

        report = f"""# Asset Vulnerability Report: {asset}

**Criticality:** {summary['criticality'].title()}
**Total Vulnerabilities:** {summary['total']}

## Severity Distribution

| Severity | Count |
|----------|-------|
"""
        for sev in ['Critical', 'High', 'Medium', 'Low']:
            report += f"| {sev} | {summary['by_severity'].get(sev, 0)} |\n"

        return report
