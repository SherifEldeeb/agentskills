#!/usr/bin/env python3
"""
Network Scanning Utility Functions

Utilities for network discovery and port scanning during penetration testing.

Usage:
    from network_scan_utils import PortScanner, HostDiscovery, ServiceDetector
"""

import re
import json
import socket
import logging
import ipaddress
from datetime import datetime
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum

logger = logging.getLogger(__name__)


class ScanTechnique(Enum):
    """Port scanning techniques."""
    TCP_SYN = 'syn'
    TCP_CONNECT = 'connect'
    TCP_ACK = 'ack'
    TCP_FIN = 'fin'
    TCP_XMAS = 'xmas'
    TCP_NULL = 'null'
    UDP = 'udp'


class PortState(Enum):
    """Port states."""
    OPEN = 'open'
    CLOSED = 'closed'
    FILTERED = 'filtered'
    OPEN_FILTERED = 'open|filtered'
    CLOSED_FILTERED = 'closed|filtered'


@dataclass
class PortResult:
    """Result of a port scan."""
    port: int
    protocol: str
    state: PortState
    service: Optional[str] = None
    version: Optional[str] = None
    banner: Optional[str] = None


@dataclass
class HostResult:
    """Result of host discovery."""
    ip: str
    hostname: Optional[str] = None
    mac: Optional[str] = None
    os: Optional[str] = None
    alive: bool = False
    ports: List[PortResult] = field(default_factory=list)


class HostDiscovery:
    """Host discovery on networks."""

    def __init__(self, target: str, timeout: float = 2.0):
        self.target = target
        self.timeout = timeout
        self.live_hosts: List[HostResult] = []
        self.scan_time = None

    def _parse_target(self) -> List[str]:
        """Parse target into list of IPs."""
        try:
            network = ipaddress.ip_network(self.target, strict=False)
            return [str(ip) for ip in network.hosts()]
        except ValueError:
            return [self.target]

    def ping_sweep(self) -> List[str]:
        """ICMP ping sweep."""
        hosts = self._parse_target()
        live = []
        logger.info(f"Starting ping sweep on {len(hosts)} hosts")
        for host in hosts:
            # Placeholder - actual implementation would send ICMP
            logger.debug(f"Pinging {host}")
        self.scan_time = datetime.now()
        return live

    def arp_discovery(self) -> List[str]:
        """ARP-based host discovery (local network)."""
        hosts = self._parse_target()
        live = []
        logger.info(f"Starting ARP discovery on {len(hosts)} hosts")
        self.scan_time = datetime.now()
        return live

    def tcp_syn_discovery(self, ports: List[int] = None) -> List[str]:
        """TCP SYN-based host discovery."""
        ports = ports or [22, 80, 443]
        hosts = self._parse_target()
        live = []
        logger.info(f"Starting TCP SYN discovery on {len(hosts)} hosts using ports {ports}")
        self.scan_time = datetime.now()
        return live

    def full_discovery(self) -> List[HostResult]:
        """Combined discovery using multiple techniques."""
        self.ping_sweep()
        self.arp_discovery()
        self.tcp_syn_discovery()
        return self.live_hosts

    def export_hosts(self, filepath: str):
        """Export discovered hosts to file."""
        with open(filepath, 'w') as f:
            for host in self.live_hosts:
                f.write(f"{host.ip}\n")
        logger.info(f"Exported {len(self.live_hosts)} hosts to {filepath}")


class PortScanner:
    """Port scanning with multiple techniques."""

    # Common ports to scan
    COMMON_PORTS = [
        21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445,
        993, 995, 1723, 3306, 3389, 5432, 5900, 8080, 8443
    ]

    def __init__(self, target: str, timeout: float = 2.0,
                 stealth: bool = False, rate: int = 1000):
        self.target = target
        self.timeout = timeout
        self.stealth = stealth
        self.rate = rate
        self.results: List[PortResult] = []
        self.scan_start = None
        self.scan_end = None

    def _parse_ports(self, ports: Union[str, List[int]]) -> List[int]:
        """Parse port specification."""
        if isinstance(ports, list):
            return ports

        port_list = []
        for part in ports.split(','):
            if '-' in part:
                start, end = part.split('-')
                port_list.extend(range(int(start), int(end) + 1))
            else:
                port_list.append(int(part))
        return port_list

    def tcp_syn_scan(self, ports: Union[str, List[int]] = '1-1000') -> List[PortResult]:
        """TCP SYN scan (half-open scan)."""
        port_list = self._parse_ports(ports)
        self.scan_start = datetime.now()
        logger.info(f"Starting TCP SYN scan on {self.target}, {len(port_list)} ports")

        for port in port_list:
            logger.debug(f"Scanning port {port}")

        self.scan_end = datetime.now()
        return self.results

    def tcp_connect_scan(self, ports: Union[str, List[int]] = '1-1000') -> List[PortResult]:
        """TCP connect scan (full connection)."""
        port_list = self._parse_ports(ports)
        self.scan_start = datetime.now()
        logger.info(f"Starting TCP connect scan on {self.target}")

        for port in port_list:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.timeout)
                result = sock.connect_ex((self.target, port))
                if result == 0:
                    self.results.append(PortResult(
                        port=port,
                        protocol='tcp',
                        state=PortState.OPEN
                    ))
                sock.close()
            except socket.error as exc:
                # Socket errors are expected for closed/filtered ports during scanning
                logger.debug(
                    "Socket error during TCP connect scan on %s:%d: %s",
                    self.target,
                    port,
                    exc,
                )

        self.scan_end = datetime.now()
        return self.results

    def udp_scan(self, ports: Union[str, List[int]] = '53,67,123,161') -> List[PortResult]:
        """UDP scan."""
        port_list = self._parse_ports(ports)
        self.scan_start = datetime.now()
        logger.info(f"Starting UDP scan on {self.target}")

        for port in port_list:
            logger.debug(f"UDP scanning port {port}")

        self.scan_end = datetime.now()
        return self.results

    def common_ports_scan(self) -> List[PortResult]:
        """Scan common ports."""
        return self.tcp_connect_scan(self.COMMON_PORTS)

    def tcp_scan(self, ports: Union[str, List[int]]) -> List[PortResult]:
        """Generic TCP scan."""
        return self.tcp_connect_scan(ports)

    def get_results(self) -> Dict[str, Any]:
        """Get scan results."""
        return {
            'target': self.target,
            'scan_start': self.scan_start.isoformat() if self.scan_start else None,
            'scan_end': self.scan_end.isoformat() if self.scan_end else None,
            'open_ports': [
                {
                    'port': r.port,
                    'protocol': r.protocol,
                    'state': r.state.value,
                    'service': r.service,
                    'version': r.version
                }
                for r in self.results if r.state == PortState.OPEN
            ]
        }

    def export_results(self, filepath: str):
        """Export results to JSON."""
        with open(filepath, 'w') as f:
            json.dump(self.get_results(), f, indent=2)
        logger.info(f"Exported results to {filepath}")

    def export_nmap_format(self, filepath: str):
        """Export in nmap-like format."""
        lines = [
            f"# Nmap scan report for {self.target}",
            f"# Scan started: {self.scan_start}",
            "",
            "PORT     STATE    SERVICE    VERSION"
        ]
        for r in self.results:
            if r.state == PortState.OPEN:
                lines.append(
                    f"{r.port}/{r.protocol}  {r.state.value}  "
                    f"{r.service or 'unknown'}  {r.version or ''}"
                )
        with open(filepath, 'w') as f:
            f.write('\n'.join(lines))


class ServiceDetector:
    """Service and version detection."""

    # Service signatures
    SERVICE_PATTERNS = {
        'ssh': rb'^SSH-',
        'http': rb'^HTTP/',
        'ftp': rb'^220[\s-]',
        'smtp': rb'^220[\s-].*SMTP',
        'mysql': rb'^\x00\x00\x00\x0a[\x35-\x39]',
        'postgresql': rb'FATAL|ERROR',
        'redis': rb'-ERR|-NOAUTH',
        'mongodb': rb'MongoDB',
    }

    def __init__(self, target: str, timeout: float = 5.0):
        self.target = target
        self.timeout = timeout

    def detect_services(self, ports: List[int]) -> List[Dict[str, Any]]:
        """Detect services on specified ports."""
        services = []
        for port in ports:
            service_info = self._detect_service(port)
            services.append(service_info)
        return services

    def _detect_service(self, port: int) -> Dict[str, Any]:
        """Detect service on a single port."""
        result = {
            'port': port,
            'service': 'unknown',
            'version': '',
            'banner': ''
        }

        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.target, port))

            # Try to grab banner
            sock.send(b'\r\n')
            banner = sock.recv(1024)
            result['banner'] = banner.decode('utf-8', errors='ignore').strip()

            # Match against patterns
            for service, pattern in self.SERVICE_PATTERNS.items():
                if re.match(pattern, banner):
                    result['service'] = service
                    break

            sock.close()
        except socket.error as e:
            logger.debug(f"Error detecting service on port {port}: {e}")

        return result

    def grab_banners(self, ports: List[int]) -> Dict[int, str]:
        """Grab banners from specified ports."""
        banners = {}
        for port in ports:
            service_info = self._detect_service(port)
            banners[port] = service_info['banner']
        return banners

    def detect_http(self, port: int) -> Dict[str, Any]:
        """Detect HTTP service details."""
        return {
            'port': port,
            'server': None,
            'title': None,
            'technologies': [],
            'headers': {}
        }

    def detect_ssl(self, port: int) -> Dict[str, Any]:
        """Detect SSL/TLS configuration."""
        return {
            'port': port,
            'version': None,
            'certificate': {},
            'cipher': None,
            'vulnerabilities': []
        }


class OSFingerprinter:
    """Operating system fingerprinting."""

    # TTL values for OS detection
    TTL_VALUES = {
        64: ['Linux', 'macOS', 'FreeBSD'],
        128: ['Windows'],
        255: ['Cisco', 'Solaris']
    }

    def __init__(self, target: str):
        self.target = target

    def fingerprint(self) -> Dict[str, Any]:
        """Perform OS fingerprinting."""
        return {
            'os': None,
            'confidence': 0,
            'details': ''
        }

    def ttl_analysis(self) -> str:
        """Analyze TTL for OS detection."""
        # Would analyze ICMP response TTL
        return 'Unknown'

    def service_inference(self) -> str:
        """Infer OS from running services."""
        return 'Unknown'


class VulnScanner:
    """Basic vulnerability scanning."""

    def __init__(self, target: str):
        self.target = target
        self.vulnerabilities = []

    def scan_common_vulns(self) -> List[Dict[str, Any]]:
        """Scan for common vulnerabilities."""
        logger.info(f"Scanning {self.target} for common vulnerabilities")
        return self.vulnerabilities

    def check_smb_vulns(self) -> List[Dict[str, Any]]:
        """Check for SMB vulnerabilities."""
        smb_vulns = []
        # Would check for MS17-010, etc.
        return smb_vulns

    def check_ssl_vulns(self) -> List[Dict[str, Any]]:
        """Check for SSL/TLS vulnerabilities."""
        ssl_vulns = []
        # Would check for Heartbleed, POODLE, etc.
        return ssl_vulns

    def check_http_vulns(self) -> List[Dict[str, Any]]:
        """Check for HTTP vulnerabilities."""
        http_vulns = []
        return http_vulns

    def check_default_credentials(self, ports: List[int]) -> List[Dict[str, Any]]:
        """Check for default credentials."""
        results = []
        for port in ports:
            results.append({
                'port': port,
                'status': 'not_tested',
                'credentials': None
            })
        return results

    def generate_report(self) -> str:
        """Generate vulnerability report."""
        report = f"""# Vulnerability Scan Report: {self.target}

## Summary

Total vulnerabilities: {len(self.vulnerabilities)}

## Findings

"""
        for vuln in self.vulnerabilities:
            report += f"""### {vuln.get('name', 'Unknown')}

- **Port:** {vuln.get('port', 'N/A')}
- **Severity:** {vuln.get('severity', 'Unknown')}
- **CVE:** {vuln.get('cve', 'N/A')}
- **Description:** {vuln.get('description', '')}

"""
        return report


class NetworkMapper:
    """Network topology mapping."""

    def __init__(self):
        self.hosts = []
        self.connections = []
        self.segments = []

    def scan_network(self, target: str):
        """Scan network and build map."""
        logger.info(f"Scanning network {target}")

    def add_host(self, ip: str, hostname: str = '', os: str = ''):
        """Add host to map."""
        self.hosts.append({
            'ip': ip,
            'hostname': hostname,
            'os': os
        })

    def add_connection(self, source: str, dest: str, label: str = ''):
        """Add connection between hosts."""
        self.connections.append({
            'source': source,
            'destination': dest,
            'label': label
        })

    def detect_segments(self) -> List[str]:
        """Detect network segments."""
        return self.segments

    def generate_topology_map(self, filepath: str):
        """Generate topology map JSON."""
        topology = {
            'hosts': self.hosts,
            'connections': self.connections,
            'segments': self.segments
        }
        with open(filepath, 'w') as f:
            json.dump(topology, f, indent=2)

    def generate_visual_map(self, filepath: str):
        """Generate visual HTML map."""
        # Would generate D3.js or similar visualization
        logger.info(f"Generating visual map: {filepath}")


class ScanScheduler:
    """Scan scheduling and management."""

    def __init__(self):
        self.jobs = []
        self.profiles = {}
        self.scan_history = []

    def create_job(self, name: str, targets: List[str],
                   scan_type: str, schedule: str) -> Dict[str, Any]:
        """Create scan job."""
        job = {
            'name': name,
            'targets': targets,
            'scan_type': scan_type,
            'schedule': schedule,
            'created_at': datetime.now().isoformat()
        }
        self.jobs.append(job)
        return job

    def add_profile(self, name: str, ports: str,
                    techniques: List[str], service_detection: bool = True):
        """Add scan profile."""
        self.profiles[name] = {
            'ports': ports,
            'techniques': techniques,
            'service_detection': service_detection
        }

    def run_scan(self, target: str, profile: str = None) -> Dict[str, Any]:
        """Run scan with optional profile."""
        logger.info(f"Running scan on {target} with profile {profile}")
        return {'target': target, 'profile': profile, 'results': []}

    def compare_scans(self, scan1_id: str, scan2_id: str) -> Dict[str, Any]:
        """Compare two scans."""
        return {
            'new_hosts': [],
            'removed_hosts': [],
            'new_ports': [],
            'closed_ports': []
        }


class NetworkAssessment:
    """Comprehensive network assessment."""

    def __init__(self, target: str):
        self.target = target
        self.discovery = HostDiscovery(target)
        self.hosts = []
        self.findings = []

    def run_full_assessment(self) -> Dict[str, Any]:
        """Run full network assessment."""
        logger.info(f"Starting full assessment of {self.target}")

        # Host discovery
        self.discovery.full_discovery()

        # Port scan each host
        for host in self.discovery.live_hosts:
            scanner = PortScanner(host.ip)
            scanner.common_ports_scan()
            host.ports = scanner.results

        # Service detection
        # Vulnerability scanning
        # OS fingerprinting

        return self.generate_report()

    def generate_report(self) -> str:
        """Generate assessment report."""
        return f"""# Network Assessment Report

## Executive Summary
- Network: {self.target}
- Live hosts: {len(self.discovery.live_hosts)}
- Critical findings: {len([f for f in self.findings if f.get('severity') == 'critical'])}

## Hosts

| IP | Hostname | OS | Open Ports |
|----|----------|-------|------------|
"""
