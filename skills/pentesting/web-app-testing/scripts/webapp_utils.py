#!/usr/bin/env python3
"""
Web Application Testing Utility Functions

Utilities for web application security testing during penetration testing.

Usage:
    from webapp_utils import WebAppScanner, VulnerabilityTester, AuthTester
"""

import re
import json
import logging
import urllib.parse
from datetime import datetime
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, field
from enum import Enum

logger = logging.getLogger(__name__)


class VulnSeverity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = 'critical'
    HIGH = 'high'
    MEDIUM = 'medium'
    LOW = 'low'
    INFO = 'info'


@dataclass
class Vulnerability:
    """Represents a discovered vulnerability."""
    name: str
    severity: VulnSeverity
    url: str
    parameter: str
    payload: str
    evidence: str
    description: str = ''
    remediation: str = ''
    cwe: str = ''
    cvss: float = 0.0


@dataclass
class Endpoint:
    """Represents a web endpoint."""
    url: str
    method: str
    params: List[str] = field(default_factory=list)
    headers: Dict[str, str] = field(default_factory=dict)
    body: Optional[str] = None


class WebAppScanner:
    """Web application crawler and analyzer."""

    def __init__(self, base_url: str, verify_ssl: bool = True):
        self.base_url = base_url.rstrip('/')
        self.verify_ssl = verify_ssl
        self.endpoints: List[Endpoint] = []
        self.forms: List[Dict] = []
        self.scripts: List[str] = []
        self.technologies: List[str] = []
        self.cookies: Dict[str, str] = {}

    def crawl(self, depth: int = 3, max_pages: int = 100) -> List[str]:
        """Crawl the web application."""
        visited = set()
        logger.info(f"Crawling {self.base_url} (depth={depth}, max={max_pages})")
        return list(visited)

    def get_endpoints(self) -> List[Dict]:
        """Get discovered endpoints."""
        return [
            {
                'url': e.url,
                'method': e.method,
                'params': e.params
            }
            for e in self.endpoints
        ]

    def get_forms(self) -> List[Dict]:
        """Get discovered forms."""
        return self.forms

    def get_scripts(self) -> List[str]:
        """Get discovered JavaScript files."""
        return self.scripts

    def analyze(self) -> Dict[str, Any]:
        """Analyze the application."""
        return {
            'technologies': self.technologies,
            'entry_points': len(self.endpoints),
            'forms': len(self.forms),
            'scripts': len(self.scripts)
        }

    def run_owasp_assessment(self) -> Dict[str, Any]:
        """Run full OWASP Top 10 assessment."""
        logger.info("Running OWASP Top 10 assessment")
        return {
            'a01_broken_access_control': [],
            'a02_cryptographic_failures': [],
            'a03_injection': [],
            'a04_insecure_design': [],
            'a05_security_misconfiguration': [],
            'a06_vulnerable_components': [],
            'a07_auth_failures': [],
            'a08_software_integrity_failures': [],
            'a09_logging_failures': [],
            'a10_ssrf': []
        }


class VulnerabilityTester:
    """General vulnerability tester."""

    def __init__(self, base_url: str, delay: float = 0):
        self.base_url = base_url.rstrip('/')
        self.delay = delay
        self.findings: List[Vulnerability] = []

    def test_sql_injection(self, path: str, param: str = None) -> Dict[str, Any]:
        """Test for SQL injection."""
        logger.info(f"Testing SQL injection on {path}")
        return {
            'vulnerable': False,
            'injection_type': None,
            'payload': None
        }

    def test_xss(self, path: str, param: str = None) -> Dict[str, Any]:
        """Test for XSS."""
        logger.info(f"Testing XSS on {path}")
        return {
            'vulnerable': False,
            'context': None,
            'payload': None
        }


class SQLInjectionTester:
    """SQL injection testing."""

    # Common SQL injection payloads
    PAYLOADS = {
        'error_based': [
            "' OR '1'='1",
            "' OR '1'='1'--",
            "' OR '1'='1'/*",
            "\" OR \"1\"=\"1",
            "1' ORDER BY 1--+",
            "1' ORDER BY 2--+",
            "1' ORDER BY 3--+",
        ],
        'union_based': [
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--",
        ],
        'blind_boolean': [
            "' AND '1'='1",
            "' AND '1'='2",
            "1 AND 1=1",
            "1 AND 1=2",
        ],
        'blind_time': [
            "'; WAITFOR DELAY '0:0:5'--",
            "'; SELECT SLEEP(5)--",
            "'; SELECT pg_sleep(5)--",
        ]
    }

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.findings = []

    def test_parameter(self, path: str, param: str,
                       method: str = 'GET') -> Dict[str, Any]:
        """Test parameter for SQL injection."""
        logger.info(f"Testing {param} parameter on {path}")
        return {
            'vulnerable': False,
            'injection_type': None,
            'payload': None,
            'evidence': None
        }

    def test_blind_boolean(self, path: str, param: str) -> Dict[str, Any]:
        """Test for boolean-based blind SQL injection."""
        return {'vulnerable': False, 'payload': None}

    def test_blind_time(self, path: str, param: str) -> Dict[str, Any]:
        """Test for time-based blind SQL injection."""
        return {'vulnerable': False, 'payload': None}

    def test_error_based(self, path: str, param: str) -> Dict[str, Any]:
        """Test for error-based SQL injection."""
        return {'vulnerable': False, 'payload': None}

    def test_union_based(self, path: str, param: str) -> Dict[str, Any]:
        """Test for UNION-based SQL injection."""
        return {'vulnerable': False, 'columns': 0, 'payload': None}

    def generate_payloads(self, dbms: str = 'generic') -> List[str]:
        """Generate SQL injection payloads."""
        payloads = []
        for category in self.PAYLOADS.values():
            payloads.extend(category)
        return payloads

    def test_all_params(self, url: str) -> List[Dict[str, Any]]:
        """Test all parameters in URL."""
        parsed = urllib.parse.urlparse(url)
        params = urllib.parse.parse_qs(parsed.query)
        results = []
        for param in params:
            result = self.test_parameter(parsed.path, param)
            results.append({'param': param, **result})
        return results


class XSSTester:
    """Cross-Site Scripting testing."""

    PAYLOADS = {
        'basic': [
            '<script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            '"><script>alert(1)</script>',
            "'-alert(1)-'",
        ],
        'html_context': [
            '<div onmouseover="alert(1)">',
            '<body onload=alert(1)>',
            '<input onfocus=alert(1) autofocus>',
        ],
        'attribute_context': [
            '" onmouseover="alert(1)',
            "' onmouseover='alert(1)",
            '" onfocus="alert(1)" autofocus="',
        ],
        'javascript_context': [
            "';alert(1)//",
            "'-alert(1)-'",
            "\\';alert(1)//",
        ],
        'dom_based': [
            '#<img src=x onerror=alert(1)>',
            'javascript:alert(1)',
        ]
    }

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.findings = []

    def test_reflected(self, path: str, param: str) -> Dict[str, Any]:
        """Test for reflected XSS."""
        logger.info(f"Testing reflected XSS on {path}?{param}=")
        return {
            'vulnerable': False,
            'context': None,
            'payload': None
        }

    def test_stored(self, submit_url: str, view_url: str,
                    param: str) -> Dict[str, Any]:
        """Test for stored XSS."""
        logger.info(f"Testing stored XSS: submit={submit_url}, view={view_url}")
        return {
            'vulnerable': False,
            'payload': None,
            'location': None
        }

    def test_dom(self, url: str) -> Dict[str, Any]:
        """Test for DOM-based XSS."""
        logger.info(f"Testing DOM XSS on {url}")
        return {
            'vulnerable': False,
            'sink': None,
            'source': None
        }

    def test_with_bypass(self, path: str, param: str,
                         bypass_type: str) -> Dict[str, Any]:
        """Test XSS with filter bypass."""
        return {'vulnerable': False, 'bypass': bypass_type}

    def test_all_inputs(self, path: str) -> List[Dict[str, Any]]:
        """Test all input fields on a page."""
        return []

    def generate_payloads(self, context: str = 'html') -> List[str]:
        """Generate context-aware XSS payloads."""
        if context in self.PAYLOADS:
            return self.PAYLOADS[context]
        return self.PAYLOADS['basic']


class AuthTester:
    """Authentication testing."""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.login_url = None
        self.username_field = None
        self.password_field = None
        self.success_indicator = None

    def set_login_form(self, url: str, username_field: str,
                       password_field: str, success_indicator: str):
        """Configure login form."""
        self.login_url = url
        self.username_field = username_field
        self.password_field = password_field
        self.success_indicator = success_indicator

    def test_username_enumeration(self, usernames: List[str]) -> Dict[str, Any]:
        """Test for username enumeration."""
        logger.info(f"Testing username enumeration with {len(usernames)} users")
        return {
            'enumerable': False,
            'method': None,
            'valid_users': []
        }

    def test_password_policy(self) -> Dict[str, Any]:
        """Test password policy requirements."""
        return {
            'min_length': None,
            'max_length': None,
            'complexity': {
                'uppercase': None,
                'lowercase': None,
                'numbers': None,
                'special': None
            }
        }

    def test_account_lockout(self) -> Dict[str, Any]:
        """Test account lockout mechanism."""
        return {
            'lockout_enabled': False,
            'attempts': None,
            'duration': None
        }

    def test_session_management(self) -> Dict[str, Any]:
        """Test session management."""
        return {
            'fixation_vulnerable': False,
            'predictable_tokens': False,
            'timeout': None,
            'secure_flag': None,
            'httponly_flag': None
        }

    def test_remember_me(self) -> Dict[str, Any]:
        """Test remember me functionality."""
        return {
            'persistent_cookie': False,
            'secure': None
        }

    def test_password_reset(self) -> Dict[str, Any]:
        """Test password reset functionality."""
        return {
            'token_in_url': False,
            'token_expiry': None,
            'rate_limited': None
        }

    def test_brute_force(self) -> Dict[str, Any]:
        """Test brute force protection."""
        logger.info("Testing brute force protection")
        return {
            'protected': False,
            'captcha': False,
            'rate_limit': None
        }


class AuthzTester:
    """Authorization testing."""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.users = {}

    def add_user(self, name: str, credentials: Dict[str, str]):
        """Add user context for testing."""
        self.users[name] = credentials

    def test_idor(self, url_pattern: str, user: str) -> Dict[str, Any]:
        """Test for Insecure Direct Object References."""
        logger.info(f"Testing IDOR on {url_pattern}")
        return {
            'vulnerable': False,
            'accessible_ids': []
        }

    def test_vertical_escalation(self, url: str, user: str) -> Dict[str, Any]:
        """Test vertical privilege escalation."""
        return {
            'vulnerable': False,
            'accessed_as': None
        }

    def test_object_references(self, urls: List[str]) -> List[Dict[str, Any]]:
        """Test insecure direct object references."""
        return []

    def test_function_access(self, urls: List[str]) -> List[Dict[str, Any]]:
        """Test function-level access control."""
        return []

    def test_forced_browsing(self, paths: List[str]) -> List[Dict[str, Any]]:
        """Test for forced browsing vulnerabilities."""
        results = []
        for path in paths:
            results.append({
                'path': path,
                'status': None,
                'accessible': False
            })
        return results


class InputValidationTester:
    """Input validation testing."""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')

    def test_file_upload(self, path: str, param: str) -> Dict[str, Any]:
        """Test file upload functionality."""
        return {
            'allowed_types': [],
            'max_size': None,
            'bypass_possible': False,
            'rce_risk': False
        }

    def test_malicious_upload(self, path: str, param: str) -> Dict[str, Any]:
        """Test with malicious file uploads."""
        return {
            'shell_upload': False,
            'polyglot': False,
            'content_type_bypass': False
        }

    def test_param_tampering(self, path: str,
                              params: Dict[str, str]) -> Dict[str, Any]:
        """Test parameter tampering."""
        return {
            'vulnerable': False,
            'tampered_params': []
        }

    def test_hpp(self, url: str) -> Dict[str, Any]:
        """Test HTTP parameter pollution."""
        return {'vulnerable': False}

    def test_header_injection(self, path: str) -> Dict[str, Any]:
        """Test header injection."""
        return {
            'vulnerable': False,
            'injection_point': None
        }

    def test_path_traversal(self, path: str) -> Dict[str, Any]:
        """Test path traversal."""
        return {
            'vulnerable': False,
            'payload': None,
            'accessible_files': []
        }

    def test_ssrf(self, path: str) -> Dict[str, Any]:
        """Test Server-Side Request Forgery."""
        return {
            'vulnerable': False,
            'type': None
        }


class BusinessLogicTester:
    """Business logic testing."""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')

    def test_workflow_bypass(self, steps: List[str]) -> Dict[str, Any]:
        """Test workflow step bypass."""
        return {
            'bypassable': False,
            'skippable_steps': []
        }

    def test_race_condition(self, url: str, method: str,
                            data: Dict, threads: int) -> Dict[str, Any]:
        """Test for race conditions."""
        logger.info(f"Testing race condition on {url} with {threads} threads")
        return {
            'vulnerable': False,
            'successful_requests': 0
        }

    def test_numeric_limits(self, path: str,
                            values: Dict[str, List]) -> Dict[str, Any]:
        """Test numeric input limits."""
        return {'issues': []}

    def test_time_based(self, path: str, param: str) -> Dict[str, Any]:
        """Test time-based logic."""
        return {'issues': []}

    def test_multistep_bypass(self, path: str) -> Dict[str, Any]:
        """Test multi-step process bypass."""
        return {'bypassable': False}


class HeaderAnalyzer:
    """Security headers analyzer."""

    SECURITY_HEADERS = [
        'Content-Security-Policy',
        'X-Frame-Options',
        'X-XSS-Protection',
        'X-Content-Type-Options',
        'Strict-Transport-Security',
        'Referrer-Policy',
        'Permissions-Policy',
        'Cross-Origin-Embedder-Policy',
        'Cross-Origin-Opener-Policy',
        'Cross-Origin-Resource-Policy'
    ]

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.headers = {}

    def analyze(self) -> Dict[str, Any]:
        """Analyze security headers."""
        return {
            'csp': None,
            'xfo': None,
            'xss_protection': None,
            'hsts': None,
            'xcto': None
        }

    def get_recommendations(self) -> List[Dict[str, str]]:
        """Get security header recommendations."""
        return []

    def get_missing_headers(self) -> List[str]:
        """Get list of missing security headers."""
        return [h for h in self.SECURITY_HEADERS if h not in self.headers]
