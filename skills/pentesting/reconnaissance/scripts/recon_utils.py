#!/usr/bin/env python3
"""
Reconnaissance Utility Functions

Utilities for OSINT and reconnaissance during penetration testing.

Usage:
    from recon_utils import PassiveRecon, DomainIntel, AttackSurfaceMapper
"""

import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)


@dataclass
class DNSRecord:
    """Represents a DNS record."""
    record_type: str
    value: str
    ttl: int = 0


@dataclass
class Subdomain:
    """Represents a discovered subdomain."""
    name: str
    ip_address: Optional[str] = None
    status_code: Optional[int] = None
    title: Optional[str] = None
    technologies: List[str] = field(default_factory=list)
    discovered_via: str = ''
    alive: bool = False


class PassiveRecon:
    """Passive reconnaissance without direct target interaction."""

    def __init__(self, target: str, rate_limit: int = 5):
        self.target = target
        self.rate_limit = rate_limit
        self.dns_info = {}
        self.subdomains = []
        self.emails = []
        self.technologies = []
        self.documents = []
        self.email_patterns = []
        self.created_at = datetime.now()

    def gather_dns_info(self) -> Dict[str, List[str]]:
        """Gather DNS information from passive sources."""
        self.dns_info = {
            'A': [],
            'AAAA': [],
            'MX': [],
            'NS': [],
            'TXT': [],
            'CNAME': [],
            'SOA': []
        }
        logger.info(f"Gathering DNS info for {self.target}")
        return self.dns_info

    def discover_subdomains(self, sources: List[str] = None) -> List[str]:
        """Discover subdomains via passive sources."""
        sources = sources or ['crt.sh', 'dnsdumpster', 'virustotal']
        discovered = []
        logger.info(f"Discovering subdomains for {self.target} via {sources}")
        return discovered

    def discover_email_patterns(self) -> List[str]:
        """Discover email address patterns."""
        patterns = [
            '{first}.{last}@' + self.target,
            '{first}{last}@' + self.target,
            '{f}{last}@' + self.target,
            '{first}_{last}@' + self.target
        ]
        self.email_patterns = patterns
        return patterns

    def identify_technologies(self) -> List[str]:
        """Identify technologies used by target."""
        self.technologies = []
        logger.info(f"Identifying technologies for {self.target}")
        return self.technologies

    def search_documents(self, filetypes: List[str] = None) -> List[Dict]:
        """Search for exposed documents."""
        self.documents = []
        logger.info(f"Searching documents for {self.target}")
        return self.documents

    def generate_report(self) -> str:
        """Generate passive reconnaissance report."""
        report = f"""# Passive Reconnaissance Report: {self.target}

**Generated:** {self.created_at.strftime('%Y-%m-%d %H:%M:%S')}

---

## DNS Information

"""
        for record_type, values in self.dns_info.items():
            if values:
                report += f"### {record_type} Records\n"
                for value in values:
                    report += f"- {value}\n"
                report += "\n"

        report += f"""## Subdomains Discovered

Total: {len(self.subdomains)}

"""
        for subdomain in self.subdomains:
            report += f"- {subdomain}\n"

        report += f"""
## Email Patterns

"""
        for pattern in self.email_patterns:
            report += f"- {pattern}\n"

        report += f"""
## Technologies Identified

"""
        for tech in self.technologies:
            report += f"- {tech}\n"

        report += f"""
## Documents Found

Total: {len(self.documents)}

"""
        for doc in self.documents:
            report += f"- {doc.get('filename', 'Unknown')}: {doc.get('url', '')}\n"

        return report

    def full_scan(self) -> Dict[str, Any]:
        """Perform full passive reconnaissance."""
        self.gather_dns_info()
        self.discover_subdomains()
        self.discover_email_patterns()
        self.identify_technologies()
        self.search_documents()
        return {
            'dns': self.dns_info,
            'subdomains': self.subdomains,
            'emails': self.emails,
            'technologies': self.technologies,
            'documents': self.documents
        }


class DomainIntel:
    """Domain intelligence gathering."""

    def __init__(self, domain: str, dns_servers: List[str] = None):
        self.domain = domain
        self.dns_servers = dns_servers or ['8.8.8.8', '1.1.1.1']
        self.records = {
            'A': [], 'AAAA': [], 'MX': [], 'NS': [],
            'TXT': [], 'CNAME': [], 'SOA': [], 'SRV': []
        }
        self.whois_data = {}
        self.related_domains = []
        self.email_security = {}
        self.zone_transfer_results = []

    def enumerate_dns_records(self) -> Dict[str, List[str]]:
        """Enumerate all DNS record types."""
        record_types = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'CNAME', 'SOA', 'SRV']
        for rtype in record_types:
            logger.info(f"Querying {rtype} records for {self.domain}")
        return self.records

    def whois_lookup(self) -> Dict[str, Any]:
        """Perform WHOIS lookup."""
        self.whois_data = {
            'domain': self.domain,
            'registrar': None,
            'creation_date': None,
            'expiration_date': None,
            'name_servers': [],
            'registrant': {},
            'admin_contact': {},
            'tech_contact': {}
        }
        logger.info(f"WHOIS lookup for {self.domain}")
        return self.whois_data

    def attempt_zone_transfer(self) -> List[str]:
        """Attempt DNS zone transfer (AXFR)."""
        logger.info(f"Attempting zone transfer for {self.domain}")
        self.zone_transfer_results = []
        return self.zone_transfer_results

    def find_related_domains(self) -> List[str]:
        """Find related domains (same registrant, similar names)."""
        self.related_domains = []
        logger.info(f"Finding related domains for {self.domain}")
        return self.related_domains

    def check_email_security(self) -> Dict[str, Any]:
        """Check SPF, DKIM, DMARC configuration."""
        self.email_security = {
            'spf': {'exists': False, 'record': None, 'policy': None},
            'dkim': {'exists': False, 'selectors': []},
            'dmarc': {'exists': False, 'record': None, 'policy': None}
        }
        logger.info(f"Checking email security for {self.domain}")
        return self.email_security

    def get_summary(self) -> str:
        """Get domain intelligence summary."""
        summary = f"""# Domain Intelligence: {self.domain}

## DNS Records

| Type | Count |
|------|-------|
"""
        for rtype, records in self.records.items():
            summary += f"| {rtype} | {len(records)} |\n"

        summary += f"""
## WHOIS Information

- **Registrar:** {self.whois_data.get('registrar', 'Unknown')}
- **Created:** {self.whois_data.get('creation_date', 'Unknown')}
- **Expires:** {self.whois_data.get('expiration_date', 'Unknown')}

## Email Security

- **SPF:** {'Configured' if self.email_security.get('spf', {}).get('exists') else 'Not configured'}
- **DKIM:** {'Configured' if self.email_security.get('dkim', {}).get('exists') else 'Not configured'}
- **DMARC:** {'Configured' if self.email_security.get('dmarc', {}).get('exists') else 'Not configured'}

## Related Domains

"""
        for domain in self.related_domains:
            summary += f"- {domain}\n"

        return summary


class SubdomainEnumerator:
    """Subdomain enumeration and verification."""

    def __init__(self, domain: str):
        self.domain = domain
        self.subdomains: List[Subdomain] = []
        self.alive_hosts: List[Subdomain] = []
        self.wordlist = []

    def enumerate_passive(self, sources: List[str] = None) -> List[str]:
        """Enumerate subdomains via passive sources."""
        sources = sources or [
            'certificate_transparency',
            'dns_records',
            'search_engines',
            'threat_intel'
        ]
        discovered = []
        for source in sources:
            logger.info(f"Enumerating from {source}")
        return discovered

    def enumerate_active(self, wordlist: str = 'subdomains-top1000.txt') -> List[str]:
        """Enumerate subdomains via active DNS bruteforce."""
        logger.info(f"Active enumeration with wordlist: {wordlist}")
        return []

    def enumerate_permutations(self, base_words: List[str]) -> List[str]:
        """Generate and test subdomain permutations."""
        permutations = []
        prefixes = ['dev', 'staging', 'test', 'api', 'admin', 'internal']
        suffixes = ['01', '02', 'new', 'old', 'backup']

        for word in base_words:
            permutations.append(f"{word}.{self.domain}")
            for prefix in prefixes:
                permutations.append(f"{prefix}-{word}.{self.domain}")
            for suffix in suffixes:
                permutations.append(f"{word}-{suffix}.{self.domain}")

        logger.info(f"Testing {len(permutations)} permutations")
        return permutations

    def verify_subdomains(self) -> List[Subdomain]:
        """Verify which subdomains are alive."""
        self.alive_hosts = [s for s in self.subdomains if s.alive]
        logger.info(f"Verified {len(self.alive_hosts)} alive hosts")
        return self.alive_hosts

    def to_json(self) -> str:
        """Export subdomains to JSON."""
        data = {
            'domain': self.domain,
            'total_discovered': len(self.subdomains),
            'alive_hosts': len(self.alive_hosts),
            'subdomains': [
                {
                    'name': s.name,
                    'ip': s.ip_address,
                    'status': s.status_code,
                    'alive': s.alive
                }
                for s in self.subdomains
            ]
        }
        return json.dumps(data, indent=2)

    def to_csv(self) -> str:
        """Export subdomains to CSV."""
        lines = ['subdomain,ip,status_code,alive']
        for s in self.subdomains:
            lines.append(f"{s.name},{s.ip_address or ''},{s.status_code or ''},{s.alive}")
        return '\n'.join(lines)


class EmailIntel:
    """Email intelligence gathering."""

    def __init__(self, domain: str):
        self.domain = domain
        self.email_format = ''
        self.exposed_emails = []
        self.verified_emails = []
        self.breached_emails = []

    def discover_format(self) -> str:
        """Discover email format pattern."""
        formats = [
            '{first}.{last}',
            '{first}{last}',
            '{f}{last}',
            '{first}_{last}',
            '{first}',
            '{last}.{first}'
        ]
        self.email_format = f"{formats[0]}@{self.domain}"
        return self.email_format

    def search_exposed_emails(self) -> List[str]:
        """Search for exposed email addresses."""
        logger.info(f"Searching exposed emails for {self.domain}")
        return self.exposed_emails

    def verify_emails(self, emails: List[str]) -> Dict[str, bool]:
        """Verify email addresses exist."""
        results = {}
        for email in emails:
            results[email] = True  # Placeholder
            logger.info(f"Verifying {email}")
        return results

    def check_breaches(self) -> List[Dict]:
        """Check for email addresses in data breaches."""
        logger.info(f"Checking breaches for {self.domain}")
        return self.breached_emails

    def generate_target_list(self) -> str:
        """Generate email target list."""
        lines = []
        for email in self.exposed_emails:
            lines.append(email)
        for email in self.verified_emails:
            if email not in lines:
                lines.append(email)
        return '\n'.join(lines)


class TechFingerprint:
    """Technology fingerprinting."""

    def __init__(self, url: str):
        self.url = url
        self.server = None
        self.powered_by = None
        self.cms = None
        self.frameworks = []
        self.js_libraries = []
        self.ssl_version = None
        self.certificate = {}
        self.waf = None
        self.headers = {}

    def analyze_headers(self) -> Dict[str, str]:
        """Analyze HTTP headers."""
        logger.info(f"Analyzing headers for {self.url}")
        return self.headers

    def detect_web_technologies(self) -> Dict[str, Any]:
        """Detect web technologies."""
        logger.info(f"Detecting technologies for {self.url}")
        return {
            'cms': self.cms,
            'frameworks': self.frameworks,
            'js_libraries': self.js_libraries
        }

    def analyze_ssl(self) -> Dict[str, Any]:
        """Analyze SSL/TLS configuration."""
        logger.info(f"Analyzing SSL for {self.url}")
        return {
            'version': self.ssl_version,
            'certificate': self.certificate
        }

    def detect_waf(self) -> Optional[str]:
        """Detect Web Application Firewall."""
        logger.info(f"Detecting WAF for {self.url}")
        return self.waf

    def generate_report(self) -> str:
        """Generate fingerprint report."""
        return f"""# Technology Fingerprint: {self.url}

## Server Information
- **Server:** {self.server or 'Unknown'}
- **Powered By:** {self.powered_by or 'Unknown'}

## Web Technologies
- **CMS:** {self.cms or 'Not detected'}
- **Frameworks:** {', '.join(self.frameworks) or 'None detected'}
- **JavaScript Libraries:** {', '.join(self.js_libraries) or 'None detected'}

## Security
- **WAF:** {self.waf or 'Not detected'}
- **SSL Version:** {self.ssl_version or 'Unknown'}
"""


class AttackSurfaceMapper:
    """Map and visualize attack surface."""

    def __init__(self, target_name: str):
        self.target_name = target_name
        self.domains = []
        self.ip_ranges = []
        self.ips = []
        self.services = []
        self.personnel = []
        self.external_services = []
        self.created_at = datetime.now()

    def add_domain(self, domain: str, notes: str = ''):
        """Add domain to attack surface."""
        self.domains.append({'domain': domain, 'notes': notes})

    def add_ip_range(self, cidr: str, notes: str = ''):
        """Add IP range to attack surface."""
        self.ip_ranges.append({'cidr': cidr, 'notes': notes})

    def add_ip(self, ip: str, notes: str = ''):
        """Add single IP to attack surface."""
        self.ips.append({'ip': ip, 'notes': notes})

    def add_service(self, url: str, description: str = ''):
        """Add service to attack surface."""
        self.services.append({'url': url, 'description': description})

    def add_person(self, name: str, role: str, email: str = ''):
        """Add person to attack surface (for social engineering scope)."""
        self.personnel.append({'name': name, 'role': role, 'email': email})

    def add_external_service(self, service: str, identifier: str):
        """Add external service to attack surface."""
        self.external_services.append({'service': service, 'identifier': identifier})

    def generate_map(self) -> str:
        """Generate attack surface map."""
        map_report = f"""# Attack Surface Map: {self.target_name}

**Generated:** {self.created_at.strftime('%Y-%m-%d %H:%M:%S')}

---

## Domains ({len(self.domains)})

| Domain | Notes |
|--------|-------|
"""
        for d in self.domains:
            map_report += f"| {d['domain']} | {d['notes']} |\n"

        map_report += f"""
## IP Ranges ({len(self.ip_ranges)})

| CIDR | Notes |
|------|-------|
"""
        for r in self.ip_ranges:
            map_report += f"| {r['cidr']} | {r['notes']} |\n"

        map_report += f"""
## Individual IPs ({len(self.ips)})

| IP | Notes |
|----|-------|
"""
        for ip in self.ips:
            map_report += f"| {ip['ip']} | {ip['notes']} |\n"

        map_report += f"""
## Services ({len(self.services)})

| URL | Description |
|-----|-------------|
"""
        for s in self.services:
            map_report += f"| {s['url']} | {s['description']} |\n"

        map_report += f"""
## Personnel ({len(self.personnel)})

| Name | Role | Email |
|------|------|-------|
"""
        for p in self.personnel:
            map_report += f"| {p['name']} | {p['role']} | {p['email']} |\n"

        map_report += f"""
## External Services ({len(self.external_services)})

| Service | Identifier |
|---------|------------|
"""
        for e in self.external_services:
            map_report += f"| {e['service']} | {e['identifier']} |\n"

        return map_report

    def export_targets(self, filepath: str):
        """Export targets to file."""
        targets = []
        for d in self.domains:
            targets.append(d['domain'])
        for ip in self.ips:
            targets.append(ip['ip'])

        with open(filepath, 'w') as f:
            f.write('\n'.join(targets))
        logger.info(f"Exported {len(targets)} targets to {filepath}")

    def export_scope_json(self, filepath: str):
        """Export scope as JSON."""
        scope = {
            'target': self.target_name,
            'generated': self.created_at.isoformat(),
            'domains': self.domains,
            'ip_ranges': self.ip_ranges,
            'ips': self.ips,
            'services': self.services,
            'personnel': self.personnel,
            'external_services': self.external_services
        }
        with open(filepath, 'w') as f:
            json.dump(scope, f, indent=2)
        logger.info(f"Exported scope to {filepath}")


class OSINTCollector:
    """Structured OSINT collection."""

    def __init__(self, target: str):
        self.target = target
        self.company_info = {}
        self.social_media = {}
        self.tech_from_jobs = []
        self.news = []
        self.data_leaks = []

    def gather_company_info(self) -> Dict[str, Any]:
        """Gather company information."""
        self.company_info = {
            'name': self.target,
            'industry': None,
            'employee_count': None,
            'founded': None,
            'headquarters': None,
            'revenue': None
        }
        logger.info(f"Gathering company info for {self.target}")
        return self.company_info

    def discover_social_media(self) -> Dict[str, str]:
        """Discover social media presence."""
        platforms = ['linkedin', 'twitter', 'facebook', 'github', 'instagram']
        self.social_media = {platform: None for platform in platforms}
        logger.info(f"Discovering social media for {self.target}")
        return self.social_media

    def analyze_job_postings(self) -> List[str]:
        """Analyze job postings for technology information."""
        logger.info(f"Analyzing job postings for {self.target}")
        return self.tech_from_jobs

    def gather_news(self) -> List[Dict]:
        """Gather news and press releases."""
        logger.info(f"Gathering news for {self.target}")
        return self.news

    def check_data_leaks(self) -> List[Dict]:
        """Check for data leaks and breaches."""
        logger.info(f"Checking data leaks for {self.target}")
        return self.data_leaks

    def generate_report(self) -> str:
        """Generate OSINT report."""
        report = f"""# OSINT Report: {self.target}

## Company Information

- **Industry:** {self.company_info.get('industry', 'Unknown')}
- **Employees:** {self.company_info.get('employee_count', 'Unknown')}
- **Headquarters:** {self.company_info.get('headquarters', 'Unknown')}

## Social Media Presence

"""
        for platform, url in self.social_media.items():
            status = url if url else 'Not found'
            report += f"- **{platform.title()}:** {status}\n"

        report += f"""
## Technologies (from Job Postings)

"""
        for tech in self.tech_from_jobs:
            report += f"- {tech}\n"

        report += f"""
## Data Leaks

"""
        for leak in self.data_leaks:
            report += f"- {leak.get('source', 'Unknown')}: {leak.get('date', 'Unknown date')}\n"

        return report
