#!/usr/bin/env python3
"""
API Security Testing Utility Functions

Utilities for API security testing during penetration testing.

Usage:
    from api_utils import APIScanner, RESTTester, GraphQLTester
"""

import json
import base64
import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)


@dataclass
class APIEndpoint:
    """Represents an API endpoint."""
    path: str
    method: str
    params: List[str] = field(default_factory=list)
    headers: Dict[str, str] = field(default_factory=dict)
    body_schema: Optional[Dict] = None
    response_schema: Optional[Dict] = None


class APIScanner:
    """API endpoint discovery and mapping."""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.endpoints: List[APIEndpoint] = []
        self.openapi_spec = None

    def discover_endpoints(self) -> List[Dict]:
        """Discover API endpoints."""
        logger.info(f"Discovering endpoints on {self.base_url}")
        return [
            {'method': e.method, 'path': e.path, 'params': e.params}
            for e in self.endpoints
        ]

    def parse_openapi(self, spec_path: str) -> Dict:
        """Parse OpenAPI/Swagger specification."""
        logger.info(f"Parsing OpenAPI spec from {spec_path}")
        return {}

    def fuzz_endpoints(self, wordlist: List[str]) -> List[Dict]:
        """Fuzz for hidden endpoints."""
        found = []
        for word in wordlist:
            logger.debug(f"Fuzzing: {word}")
        return found

    def detect_versions(self) -> List[str]:
        """Detect API versions."""
        versions = []
        test_paths = ['/api/v1', '/api/v2', '/api/v3', '/v1', '/v2']
        for path in test_paths:
            logger.debug(f"Testing version: {path}")
        return versions

    def export_map(self, filepath: str):
        """Export endpoint map."""
        data = {
            'base_url': self.base_url,
            'endpoints': [
                {'method': e.method, 'path': e.path, 'params': e.params}
                for e in self.endpoints
            ]
        }
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)


class RESTTester:
    """REST API security tester."""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.findings = []

    def discover_endpoints(self) -> List[Dict]:
        """Discover REST endpoints."""
        scanner = APIScanner(self.base_url)
        return scanner.discover_endpoints()

    def test_authentication(self) -> Dict[str, Any]:
        """Test authentication mechanisms."""
        return {
            'methods': [],
            'vulnerabilities': []
        }

    def test_authorization(self) -> Dict[str, Any]:
        """Test authorization controls."""
        return {
            'issues': []
        }


class AuthTester:
    """API authentication testing."""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')

    def test_jwt(self, endpoint: str) -> Dict[str, Any]:
        """Test JWT security."""
        return {
            'algorithm': None,
            'none_vuln': False,
            'weak_secret': False,
            'exp_check': True,
            'signature_verified': True
        }

    def test_api_key(self, endpoint: str, header: str) -> Dict[str, Any]:
        """Test API key security."""
        return {
            'key_in_url': False,
            'enumerable': False,
            'rate_limited': True
        }

    def test_oauth(self, endpoint: str) -> Dict[str, Any]:
        """Test OAuth implementation."""
        return {
            'pkce': False,
            'state': False,
            'redirect_validation': False,
            'scope_validation': True
        }

    def test_bearer_token(self, endpoint: str) -> Dict[str, Any]:
        """Test bearer token security."""
        return {
            'validated': True,
            'expiry': None,
            'revocable': None
        }

    def test_brute_force(self, endpoint: str) -> Dict[str, Any]:
        """Test brute force protection."""
        return {
            'protected': False,
            'lockout': False,
            'rate_limit': None
        }

    def decode_jwt(self, token: str) -> Dict[str, Any]:
        """Decode JWT token."""
        try:
            parts = token.split('.')
            if len(parts) != 3:
                return {'error': 'Invalid JWT format'}

            header = json.loads(base64.b64decode(parts[0] + '=='))
            payload = json.loads(base64.b64decode(parts[1] + '=='))
            return {
                'header': header,
                'payload': payload,
                'signature': parts[2]
            }
        except Exception as e:
            return {'error': str(e)}


class BOLATester:
    """Broken Object Level Authorization testing."""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.users = {}
        self.findings = []

    def add_user(self, name: str, headers: Dict[str, str]):
        """Add user context."""
        self.users[name] = headers

    def test_endpoint(self, endpoint: str, user: str,
                      id_param: str, test_ids: List[str]) -> Dict[str, Any]:
        """Test endpoint for BOLA."""
        logger.info(f"Testing BOLA on {endpoint}")
        return {
            'vulnerable': False,
            'accessible_ids': [],
            'evidence': []
        }

    def test_batch_endpoint(self, endpoint: str) -> Dict[str, Any]:
        """Test batch endpoint for BOLA."""
        return {'vulnerable': False}

    def test_uuid_enumeration(self, endpoint: str) -> Dict[str, Any]:
        """Test UUID-based endpoints."""
        return {'vulnerable': False, 'predictable': False}

    def generate_report(self) -> str:
        """Generate BOLA test report."""
        report = "# BOLA Test Report\n\n"
        for finding in self.findings:
            report += f"## {finding['endpoint']}\n"
            report += f"Vulnerable: {finding['vulnerable']}\n\n"
        return report


class GraphQLTester:
    """GraphQL API security testing."""

    INTROSPECTION_QUERY = '''
    query IntrospectionQuery {
        __schema {
            types { name kind }
            queryType { name }
            mutationType { name }
        }
    }
    '''

    def __init__(self, endpoint: str):
        self.endpoint = endpoint
        self.schema = None

    def introspect(self) -> Dict[str, Any]:
        """Perform introspection query."""
        logger.info(f"Introspecting {self.endpoint}")
        return {
            'types': [],
            'queries': [],
            'mutations': [],
            'subscriptions': []
        }

    def test_injection(self) -> Dict[str, Any]:
        """Test for injection vulnerabilities."""
        return {
            'sqli': False,
            'nosqli': False,
            'command': False
        }

    def test_dos_query(self) -> Dict[str, Any]:
        """Test for DoS via complex queries."""
        return {
            'depth_limit': None,
            'complexity_limit': None,
            'batch_limit': None,
            'circular_queries': False
        }

    def test_authorization(self) -> Dict[str, Any]:
        """Test authorization on fields."""
        return {'issues': []}

    def export_schema(self, filepath: str):
        """Export GraphQL schema."""
        if self.schema:
            with open(filepath, 'w') as f:
                f.write(str(self.schema))

    def generate_test_queries(self) -> List[str]:
        """Generate test queries from schema."""
        return []


class RateLimitTester:
    """API rate limiting testing."""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')

    def test_limits(self, endpoint: str, requests: int = 100) -> Dict[str, Any]:
        """Test rate limits."""
        logger.info(f"Testing rate limits on {endpoint}")
        return {
            'requests_per_minute': None,
            'requests_per_hour': None,
            'headers': {
                'X-RateLimit-Limit': None,
                'X-RateLimit-Remaining': None,
                'X-RateLimit-Reset': None
            }
        }

    def test_bypass(self, endpoint: str) -> Dict[str, Any]:
        """Test rate limit bypass techniques."""
        return {
            'ip_rotation': False,
            'headers': {
                'X-Forwarded-For': False,
                'X-Real-IP': False,
                'X-Originating-IP': False
            },
            'case_variation': False,
            'path_variation': False
        }

    def test_limit_scope(self, endpoint: str) -> Dict[str, Any]:
        """Test if limits are per-user or global."""
        return {
            'scope': 'unknown',
            'per_user': None,
            'per_ip': None,
            'global': None
        }


class MassAssignmentTester:
    """Mass assignment vulnerability testing."""

    COMMON_FIELDS = [
        'role', 'admin', 'isAdmin', 'is_admin',
        'permissions', 'privilege', 'access_level',
        'balance', 'credits', 'points',
        'verified', 'active', 'approved',
        'password', 'password_hash'
    ]

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')

    def test_endpoint(self, endpoint: str, method: str,
                      original_data: Dict, test_fields: List[str]) -> Dict[str, Any]:
        """Test endpoint for mass assignment."""
        logger.info(f"Testing mass assignment on {endpoint}")
        return {
            'vulnerable': False,
            'assignable': [],
            'rejected': []
        }

    def discover_fields(self, endpoint: str) -> Dict[str, Any]:
        """Discover potential fields from response."""
        return {
            'fields': [],
            'sensitive': []
        }

    def test_registration(self, endpoint: str) -> Dict[str, Any]:
        """Test registration for mass assignment."""
        return self.test_endpoint(
            endpoint, 'POST', {}, self.COMMON_FIELDS
        )


class DataExposureTester:
    """Excessive data exposure testing."""

    SENSITIVE_PATTERNS = {
        'password': r'password|passwd|pwd',
        'api_key': r'api.?key|apikey|api.?token',
        'secret': r'secret|private.?key',
        'ssn': r'ssn|social.?security',
        'credit_card': r'card.?number|credit.?card|cc.?num',
        'internal_id': r'internal.?id|_id$'
    }

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')

    def analyze_response(self, endpoint: str) -> Dict[str, Any]:
        """Analyze response for sensitive data."""
        return {
            'sensitive': [],
            'pii': [],
            'internal': []
        }

    def compare_responses(self, endpoint: str, ids: List[str]) -> Dict[str, Any]:
        """Compare responses for different IDs."""
        return {
            'inconsistent': [],
            'extra_fields': []
        }

    def test_error_exposure(self, endpoint: str) -> Dict[str, Any]:
        """Test error responses for data exposure."""
        return {
            'stack_traces': False,
            'paths': [],
            'db_info': False
        }
